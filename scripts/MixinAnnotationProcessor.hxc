import funkin.play.song.Song;
import funkin.util.ReflectUtil;
import hscript.Expr;
import polymod.hscript._internal.PolymodClassDeclEx;

/**
 * MixinAnnotationProcessor handles applying mixins defined via metadata (annotations)
 *
 * It supports @:Overwrite, @:Inject, @:ModifyReturn, and @:InjectFunction
 */
class MixinAnnotationProcessor {

    /**
     * Apply all mixins from the `source` class to the `targetInstance`.
     * This iterates both instance and static fields of the source class.
     * @param source The class containing mixins.
     * @param target The object/class to apply mixins to.
     * @return true if the class definition was found and processing occurred, false otherwise.
     */
    public static function applyMixins(source:Dynamic, target:Dynamic):Bool {
        var _c:PolymodClassDeclEx = ReflectUtil.getField(source, "_c");

        if (_c == null) {
            trace("No class definition found.");
            return false;
        }

        applyFieldMixins(_c.fields, source, target, _c.name);
        applyFieldMixins(_c.staticFields, source, target, _c.name);

        return true;
    }

    public static function applyModuleMixins(source:Dynamic, className:String) {
        return applyMixins(source, ASTUtil.getScriptedModule(className));
    }

    public static function applySongMixins(source:Dynamic, id:String, ?params:SongParams) {
        return applyMixins(source, ASTUtil.getScriptedSong(id, params));
    }

    public static function applyLevelMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedLevel(id));
    }

    public static function applyNoteStyleMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedNoteStyle(id));
    }

    public static function applyPlayerMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedPlayer(id));
    }

    public static function applyConversationMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedConversation(id));
    }

    public static function applyDialogueMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedDialogue(id));
    }

    public static function applySpeakerMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedSpeaker(id));
    }

    public static function applyAlbumMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedAlbum(id));
    }

    public static function applyStageMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedStage(id));
    }

    public static function applyStickerMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedSticker(id));
    }

    public static function applyFreeplayStyleMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedFreeplayStyle(id));
    }

    public static function applySongEventMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedSongEvent(id));
    }

    public static function applyNoteKindMixins(source:Dynamic, id:String) {
        return applyMixins(source, ASTUtil.getScriptedNoteKind(id));
    }

    // WHY THE HELL IS THIS NOT WORKING AND IT GETS REPLACED IF YOU FETCH THE CHARACTER AGAIN
/*    public static function applyCharacterMixin(source:Dynamic, target:String) {
        if (ASTUtil.getScriptedCharacter(target) == null) return false;
        else return applyMixins(source, ASTUtil.getScriptedCharacter(target));
    }*/

    /**
     * Iterates a list of fields and applies mixins based on their metadata.
     * @param fields The array of fields (instance or static) from a class.
     * @param target The object/class to apply the mixins to.
     * @param source The mixin source class.
     * @param className Name of the source class for trace/debugging.
     */
    public static function applyFieldMixins(fields:Array<FieldDecl>, source:Dynamic, target:Dynamic, className:String) {
        if (fields == null) return;
        for (field in fields) {
            for (meta in field.meta) {
                var funcName = field.name;
                handleMixins(meta, funcName, source, target, className);
            }
        }
    }

    public static function handleMixins(meta:Metadata, funcName:String, source:Dynamic, target:Dynamic, className:String) {
        return switch (meta.name) {
            case ":Overwrite":
                var methodName:String = retrieveParams(meta, ["method"]).method;
                if (methodName != null) {
                    trace("Overwriting method: " + methodName + "() with " + funcName + "() from class " + className);
                    PolyMixin.overwrite(target, methodName, source, funcName);
                } else trace("Warning: method name is null for " + funcName);
            case ":Inject":
                var params:InjectionParams = retrieveParams(meta, ["method", "at", "target", "ordinal", "shift"]);
                if (params.method != null) {
                    trace("Injecting into method: " + params.method + "() with params: " + params + " and function: " + funcName + "() from class " + className);
                    switch (params.at) {
                        case "INVOKE":
                            if (params.target != null) PolyMixin.injectByNameStr(target, params.method, source, funcName, params.at, params.target, params.ordinal, params.shift);
                            else trace("Warning: target is null for " + funcName);
                        default:
                            PolyMixin.injectByNameStr(target, params.method, source, funcName, params.at);
                    }
                } else trace("Warning: method name is null for " + funcName);
            case ":ModifyReturn":
                var params:ModifyReturnParams = retrieveParams(meta, ["method", "at", "call"]);
                if (params.method != null) {
                    trace("Modifying return from method: " + params.method + "() with params: " + params + " and function: " + funcName + "() from class " + className);
                    if (params.method != null) PolyMixin.modifyByName(target, params.method, source, funcName, params.call);
                } else trace("Warning: method name is null for " + funcName);
            case ":InjectFunction":
                trace("Injecting function: " + funcName + "() from class " + className);
                PolyMixin.injectFunction(target, source, funcName);
        }
    }

    public static function retrieveParams(meta:Metadata, ?allowed:Array<String>):Dynamic {
        var result:Dynamic = {};
        for (param in meta.params) {
            switch (param.e) {
                case Expr.EBinop(_, e1, e2):
                    switch (e1.e) {
                        case Expr.EIdent(paramName):
                            if (allowed == null || allowed.indexOf(paramName) != -1) {
                                var value:Dynamic = null;

                                switch (e2.e) {
                                    case Expr.EConst(c):
                                        switch (c) {
                                            case Const.CString(str):
                                                value = str;
                                            case Const.CInt(i):
                                                value = i;
                                        }
                                    case Expr.EIdent(id):
                                        value = id;
                                    case _:
                                        trace("Unhandled RHS for " + paramName + ": " + e2.e);
                                }

                                ReflectUtil.setField(result, paramName, value);
                            }
                    }
            }
        }

        return result;
    }
}

typedef BasicParams = {method:String}
typedef InjectionParams = {method:String, at:String, target:String, ordinal:Int, shift:String}
typedef ModifyReturnParams = {method:String, at:String, call:String}
