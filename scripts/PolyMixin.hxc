import funkin.modding.events.ScriptEvent;
import funkin.modding.module.ScriptedModule;
import funkin.util.ReflectUtil;
import hscript.Expr;

class PolyMixin extends ScriptedModule {
    var injected = false;

    var cachedFuncDecl:Map<String, FunctionDecl>;

    function new() {
        super("PolyMixins");
        cachedFuncDecl = ReflectUtil.getField(this, "_cachedFunctionDecls");
    }

    function testMixin() {
        trace("Injection in test() was successful!");
        trace("Injection in test() was successful! x2");
    }

    override public function onStateChangeBegin(event:StateChangeScriptEvent) {
        TestClass.instance.test();
    }

    override public function onUpdate(event:UpdateScriptEvent) {
        if (!injected) {
            var success = injectByName(TestClass.instance, "test", this, "testMixin", At.RETURN);
            if (success) trace("Function injection succeeded!");
            injected = true;
        }
    }

    /**
     * Injects a source function into a target function by name.
     *
     * @param targetInstance The instance whose function will be modified.
     * @param targetFuncName Name of the target function to modify.
     * @param sourceInstance The instance containing the source function.
     * @param sourceFuncName Name of the source function to inject.
     * @return True if injection succeeded, false otherwise.
     */
    public static function injectByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, at:At = At.HEAD):Bool {
        if (at == null) at = At.TAIL;
        var targetFuncs:Map<String, FunctionDecl> = ReflectUtil.getField(targetInstance, "_cachedFunctionDecls");
        var sourceFuncs:Map<String, FunctionDecl> = ReflectUtil.getField(sourceInstance, "_cachedFunctionDecls");
        if (targetFuncs == null || sourceFuncs == null) return false;

        var targetFunc = targetFuncs.get(targetFuncName);
        var sourceFunc = sourceFuncs.get(sourceFuncName);

        if (targetFunc == null || sourceFunc == null) return false;

        var newFunc = inject(targetFunc, sourceFunc, at);
        targetFuncs.set(targetFuncName, newFunc);

        return true;
    }

    /**
     * Injects the contents of one function into another at runtime by manipulating their ASTs.
     *
     * @param targetFunc The target function whose body will be modified.
     * @param sourceFunc The source function whose expressions will be injected.
     * @return The modified `targetFunc` function declaration with `sourceFunc`'s expressions appended.
     *
     *
     * @example
     * var injectedFunc = inject(originalFunction, mixinFunction);
     * // originalFunction now executes both its original code and the code from mixinFunction
     */
    public static function inject(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, at:At = At.HEAD):FunctionDecl {
        var sourceExpr:Expr.EBlock = sourceFunc.expr.e;
        var sourceExprs:Array<Expr> = [];

        switch (sourceExpr) {
            case Expr.EBlock(exprs):
                sourceExprs = exprs;
            default:
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                switch (at) {
                    case At.HEAD:
                        for (i in 0...sourceExprs.length) targetExprs.insert(i, sourceExprs[i]);
                    case At.RETURN:
                        for (i in 0...targetExprs.length) {
                            switch (targetExprs[i].e) {
                                case Expr.EReturn(returnExpr):
                                    trace("Found return at index " + i + ", injecting code before it");
                                    for (j in 0...sourceExprs.length) targetExprs.insert(i + j, sourceExprs[j]);
                            }
                        }
                    case At.TAIL:
                        for (expr in sourceExprs) targetExprs.push(expr);
                }
            default:
                trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    /**
     * Replaces the contents of one function with another at runtime.
     *
     * @param targetFunc The target function that would be replaced.
     * @param sourceFunc The source function whose body will be used.
     * @return The source function `sourceFunc` whose expressions will be replaced with.
     *
     *
     * @example
     * var replacedFunc = replace(originalFunction, mixinFunction);
     * // injectedFunc is now mixinFunction
     */
    public static function replace(targetFunc:FunctionDecl, sourceFunc:FunctionDecl):FunctionDecl {
        return sourceFunc;
    }
}

enum At {
    HEAD; // Inject at beginning
    RETURN; //Before every return statement
    TAIL; // Inject at end
}