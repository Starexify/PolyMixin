import funkin.modding.module.ScriptedModule;
import funkin.util.ReflectUtil;
import hscript.Expr;
import Lambda;

/**
 * Utility module providing static methods and functions for injection, overwriting or modifying
 * `PolymodScriptedClass` instances dynamically
 */
class PolyMixin extends ScriptedModule {

    function new() {
        super("PolyMixins");
    }

    /**
     * Injects a function from one instance into another instance.
     *
     * @param targetInstance The instance whose function definitions will be modified.
     * @param sourceInstance The instance containing the source function.
     * @param sourceFuncName The name of the function to inject from the source instance.
     * @return True if injection succeeded, false otherwise.
     *
     *
     * @note This method modifies both the function cache and the AST field list.
     */
    public static function injectFunction(targetInstance:Dynamic, sourceInstance:Dynamic, sourceFuncName:String):Bool {
        var targetFuncs:Map<String, FunctionDecl> = ReflectUtil.getField(targetInstance, "_cachedFunctionDecls");
        var targetFields:Array<FieldDecl> = ReflectUtil.getField(targetInstance, "_c").fields;
        var cachedFields:Map<String, FieldDecl> = ReflectUtil.getField(targetInstance, "_cachedFieldDecls");

        var sourceFuncs:Map<String, FunctionDecl> = ReflectUtil.getField(sourceInstance, "_cachedFunctionDecls");
        var sourceFields:Array<FieldDecl> = ReflectUtil.getField(sourceInstance, "_c").fields;

        if (targetFuncs == null || sourceFuncs == null || targetFields == null || cachedFields == null) return false;

        var sourceFunc = sourceFuncs.get(sourceFuncName);
        var sourceField:FieldDecl = Lambda.find(sourceFields, (f) -> f.name == sourceFuncName);
        if (sourceFunc == null || sourceField == null) return false;

        targetFields.push(sourceField);
        cachedFields.set(sourceFuncName, sourceField);
        targetFuncs.set(sourceFuncName, sourceFunc);

        return true;
    }

    /**
     * Injects a source function into a target function by name.
     *
     * @param targetInstance The instance whose function will be modified.
     * @param targetFuncName Name of the target function to modify.
     * @param sourceInstance The instance containing the source function.
     * @param sourceFuncName Name of the source function to inject.
     * @return True if injection succeeded, false otherwise.
     */
    public static function injectByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, at:At = At.HEAD):Bool {
        if (at == null) at = At.TAIL;
        var targetFuncs:Map<String, FunctionDecl> = ReflectUtil.getField(targetInstance, "_cachedFunctionDecls");
        var sourceFuncs:Map<String, FunctionDecl> = ReflectUtil.getField(sourceInstance, "_cachedFunctionDecls");
        if (targetFuncs == null || sourceFuncs == null) return false;

        var targetFunc = targetFuncs.get(targetFuncName);
        var sourceFunc = sourceFuncs.get(sourceFuncName);

        if (targetFunc == null || sourceFunc == null) return false;

        var newFunc = inject(targetFunc, sourceFunc, at);
        targetFuncs.set(targetFuncName, newFunc);

        return true;
    }

    /**
     * Injects the contents of one function into another at runtime by manipulating their ASTs.
     *
     * @param targetFunc The target function whose body will be modified.
     * @param sourceFunc The source function whose expressions will be injected.
     * @return The modified `targetFunc` function declaration with `sourceFunc`'s expressions appended.
     *
     *
     * @example
     * var injectedFunc = inject(originalFunction, mixinFunction);
     * // originalFunction now executes both its original code and the code from mixinFunction
     */
    public static function inject(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, at:At = At.HEAD):FunctionDecl {
        var sourceExpr:Expr.EBlock = sourceFunc.expr.e;
        var sourceExprs:Array<Expr> = [];

        switch (sourceExpr) {
            case Expr.EBlock(exprs):
                sourceExprs = exprs;
            default:
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                switch (at) {
                    case At.HEAD:
                        for (i in 0...sourceExprs.length) targetExprs.insert(i, sourceExprs[i]);
                    case At.RETURN:
                        for (i in 0...targetExprs.length) {
                            switch (targetExprs[i].e) {
                                case Expr.EReturn(returnExpr):
                                    trace("Found return at index " + i + ", injecting code before it");
                                    for (j in 0...sourceExprs.length) targetExprs.insert(i + j, sourceExprs[j]);
                            }
                        }
                    case At.TAIL:
                        for (expr in sourceExprs) targetExprs.push(expr);
                }
            default:
                trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    /**
     * Replaces the contents of one function with another at runtime.
     *
     * @param targetFunc The target function that would be replaced.
     * @param sourceFunc The source function whose body will be used.
     * @return The source function `sourceFunc` whose expressions will be replaced with.
     *
     *
     * @example
     * var replacedFunc = replace(originalFunction, mixinFunction);
     * // injectedFunc is now mixinFunction
     */
    public static function overwrite(targetFunc:FunctionDecl, sourceFunc:FunctionDecl):FunctionDecl {
        return sourceFunc;
    }
}

enum At {
    HEAD; // Inject at beginning
    RETURN; //Before every return statement
    TAIL; // Inject at end
}