import funkin.modding.module.ScriptedModule;
import funkin.util.ReflectUtil;
import hscript.Expr;
import Lambda;

/**
 * Utility module providing methods and functions for injection, overwriting or modifying
 * `PolymodScriptedClass` instances dynamically by manipulating their AST.
 */
class PolyMixin extends ScriptedModule {
    private static var _instance:PolyMixin;
    public static var instance(get, set):PolyMixin;

    static function set_instance(value:PolyMixin):PolyMixin { return _instance = value; }

    static function get_instance():PolyMixin { return _instance; }

    function new() {
        super("PolyMixin");
        PolyMixin.instance = this;
    }

    // MARK: - Public API Methods

    public static function modifyByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, callFuncName:String, at:At, ?target:String, ?ordinal:Int):Bool {
        at = at ?? At.RETURN;

        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        var callFunc = validation.sourceFuncs.get(callFuncName);
        if (callFunc == null) {
            trace("Call function " + callFuncName + " not found");
            return false;
        }

        var newFunc = switch (at) {
            case At.RETURN:
                injectFunction(targetInstance, sourceInstance, sourceFuncName);
                modifyReturnValue(validation.targetFunc, callFunc, sourceFuncName);
            case At.INVOKE:
                injectFunction(targetInstance, sourceInstance, sourceFuncName);
                modifyExprValue(validation.targetFunc, callFunc, sourceFuncName, target, ordinal);
            default:
                trace("Only At.RETURN/At.INVOKE works at the moment");
                return false;
        }

        validation.targetFuncs.set(targetFuncName, newFunc);
        return true;
    }

    public static function injectByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, at:At, ?target:String, ?ordinal:Int, ?shift:Shift):Bool {
        at = at ?? At.HEAD;

        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        var newFunc = switch (at) {
            case At.INVOKE: injectAtTarget(validation.targetFunc, validation.sourceFunc, target, ordinal, shift);
            default: inject(validation.targetFunc, validation.sourceFunc, at, ordinal);
        }

        validation.targetFuncs.set(targetFuncName, newFunc);
        return true;
    }

    public static function injectByNameStr(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, at:String, ?target:String, ?ordinal:Int, ?shift:String):Bool {
        return injectByName(targetInstance, targetFuncName, sourceInstance, sourceFuncName, instance.atFromStr(at), target, ordinal, instance.shiftFromStr(shift));
    }

    public static function overwrite(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String):Bool {
        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        validation.targetFuncs.set(targetFuncName, validation.sourceFunc);
        return true;
    }

    // MARK: - Core Injection Logic

    public static function modifyExprValue(targetFunc:FunctionDecl, callFunc:FunctionDecl, sourceFuncName:String, ?target:String, ?ordinal:Int):FunctionDecl {
        /*      if (target == "" || target == null) {
            trace("No mixins applied to this function. `target` injection param is null or empty, give an actual target!");
            return targetFunc;
        }*/
        if (ordinal == null) ordinal = 0;

        var newCall = switch (callFunc.expr.e) {
            case Expr.EBlock(expr): expr[0].e;
            default:
                trace("The source function " + sourceFuncName + " must provide an empty function recall for mixins to be able to modify the return value!");
                return targetFunc;
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var exprFound = false;
                var totalIfCount = 0;
                var matchingIfCount = 0;

                for (i in 0...targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.EIf(c, e1, e2):
                            var matchesTarget = true;
                            if (target != null)
                                matchesTarget = switch (c.e) {
                                    case Expr.EIdent(name):
                                        name == target;
                                    default: false;
                                }

                            if (matchesTarget) {
                                var shouldModify = true;
                                if (ordinal != null) shouldModify = (matchingIfCount == ordinal);

                                if (shouldModify) {
                                    var oldExpr = targetExprs[i].e;
                                    var wrappedCondE = wrapExpr(oldExpr, newCall, sourceFuncName, target, ordinal);
                                    targetExprs[i].e = wrappedCondE;
                                    exprFound = true;

                                    //trace("Modified matching if statement #" + matchingIfCount + " (total if #" + totalIfCount + ")");
                                }

                                matchingIfCount++;
                            }

                            totalIfCount++;
                        default: trace("No if statement found in the function, no mixins were applied!");
                    }
                }

            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function wrapExpr(oldExpr:Expr, newCall:Expr, sourceFuncName:String, target:String, ordinal:Int):Expr {
        switch (oldExpr) {
            case Expr.EIf(expr, e1, e2):
                switch (newCall) {
                    case Expr.ECall(callExpr, params): params[0].e = expr.e;
                }
                expr.e = newCall;
        }

        return oldExpr;
    }

    public static function modifyReturnValue(targetFunc:FunctionDecl, callFunc:FunctionDecl, sourceFuncName:String):FunctionDecl {
        var newCall = switch (callFunc.expr.e) {
            case Expr.EBlock(expr): expr[0].e;
            default:
                trace("The source function " + sourceFuncName + " must provide an empty function recall for mixins to be able to modify the return value!");
                return targetFunc;
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var returnFound = false;
                for (i in 0...targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.EReturn(e):
                            var oldReturn = targetExprs[i];
                            var wrappedReturn = wrapReturn(oldReturn, newCall, sourceFuncName);
                            targetExprs[i] = wrappedReturn;
                            returnFound = true;
                        default: trace("No return statement found in the function, no mixins were applied!");
                    }
                }
                if (!returnFound) trace("No return statement found in the function, no mixins were applied!");
            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function wrapReturn(oldReturn:Expr, newCall:Expr, sourceFuncName:String):Expr {
        switch (oldReturn.e) {
            case Expr.EReturn(expr):
                var original:Expr = expr.e;
                switch (newCall) {
                    case Expr.ECall(callExpr, params): params[0].e = original;
                    default:
                        trace("Invalid call expression in source function " + sourceFuncName);
                        return oldReturn;
                }
                expr.e = newCall;
        }
        return oldReturn;
    }

    public static function injectFunction(targetInstance:Dynamic, sourceInstance:Dynamic, sourceFuncName:String):Bool {
        var targetFuncs = ASTUtil.getFuncCache(targetInstance);
        var targetFields = ASTUtil.getFields(targetInstance);
        var sourceFuncs:Map<String, FunctionDecl> = ASTUtil.getFuncCache(sourceInstance);

        if (targetFuncs == null || sourceFuncs == null || targetFields == null) {
            trace("Failed to get required caches/fields");
            return false;
        }

        var sourceFunc = sourceFuncs.get(sourceFuncName);
        if (sourceFunc == null) {
            trace("Source function " + sourceFuncName + " not found");
            return false;
        }

        var sourceFields:Array<FieldDecl> = ReflectUtil.getField(sourceInstance, "_c").fields;
        var sourceField:FieldDecl = Lambda.find(sourceFields, (f) -> f.name == sourceFuncName);

        if (sourceField == null) {
            trace("Source field " + sourceFuncName + " not found");
            return false;
        }

        targetFields.fields.push(sourceField);
        targetFields.cached.set(sourceFuncName, sourceField);
        targetFuncs.set(sourceFuncName, sourceFunc);

        return true;
    }

    public static function inject(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, at:At, ?ordinal:Int):FunctionDecl {
        var sourceExprs = extractSourceExpressions(sourceFunc);
        if (sourceExprs == null) return targetFunc;

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                switch (at) {
                    case At.HEAD: for (i in 0...sourceExprs.length) targetExprs.insert(i, sourceExprs[i]);
                    case At.RETURN: injectAtReturn(targetExprs, sourceExprs, ordinal);
                    case At.TAIL: for (expr in sourceExprs) targetExprs.push(expr);
                }
            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function injectAtReturn(targetExprs:Array<Expr>, sourceExprs:Array<Expr>, ordinal:Int) {
        if (ordinal == null) ordinal = -1;

        var i = 0;
        var returnCount = 0;
        while (i < targetExprs.length) {
            switch (targetExprs[i].e) {
                case Expr.EReturn(_):
                    if (ordinal == -1 || ordinal == returnCount) {
                        //trace("Found return #" + returnCount + " at index " + i + ", injecting code before it");
                        for (j in 0...sourceExprs.length) targetExprs.insert(i + j, sourceExprs[j]);
                        i += sourceExprs.length;
                    }
                    returnCount++;
                    i++;

                case Expr.EIf(condition, thenExpr, elseExpr):
                    //trace("Found if at index " + i + ", trying to inject code inside it");

                    switch (thenExpr.e) {
                        case Expr.EBlock(thenExprs):
                            returnCount = processReturns(thenExprs, sourceExprs, ordinal, returnCount);
                        default:
                    }

                    if (elseExpr != null) {
                        switch (elseExpr.e) {
                            case Expr.EBlock(elseExprs):
                                returnCount = processReturns(elseExprs, sourceExprs, ordinal, returnCount);
                            default:
                        }
                    }

                    i++;
                default: i++;
            }
        }
    }

    public static function processReturns(blockExprs:Array<Expr>, sourceExprs:Array<Expr>, ordinal:Int, returnCountRef:Int) {
        var i = 0;
        var currentReturnCount = returnCountRef;

        while (i < blockExprs.length) {
            switch (blockExprs[i].e) {
                case Expr.EReturn(_):
                    if (ordinal == -1 || ordinal == currentReturnCount) {
                        //trace("Found return #" + currentReturnCount + " in block at index " + i);
                        for (j in 0...sourceExprs.length) blockExprs.insert(i + j, sourceExprs[j]);
                        i += sourceExprs.length;
                    }
                    currentReturnCount++;
                    i++;

                case Expr.EIf(_, thenExpr, elseExpr):
                    switch (thenExpr.e) {
                        case Expr.EBlock(thenExprs):
                            currentReturnCount = processReturns(thenExprs, sourceExprs, ordinal, currentReturnCount);
                        default:
                    }
                    if (elseExpr != null) {
                        switch (elseExpr.e) {
                            case Expr.EBlock(elseExprs):
                                currentReturnCount = processReturns(elseExprs, sourceExprs, ordinal, currentReturnCount);
                            default:
                        }
                    }
                    i++;

                default: i++;
            }
        }

        return currentReturnCount;
    }

    public static function injectAtTarget(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, target:String, ordinal:Int, shift:Shift):FunctionDecl {
        if (target == "" || target == null) {
            trace("No mixins applied to this function. `target` injection param is null or empty, give an actual target!");
            return targetFunc;
        }
        if (shift == null) shift = Shift.BEFORE;
        if (ordinal == null) ordinal = 0;

        var sourceExprs = extractSourceExpressions(sourceFunc);
        if (sourceExprs == null) return targetFunc;

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var matchCount = 0;
                var i = 0;
                var injectionPerformed = false;

                while (i < targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.ECall(expr, params):
                            var methodName = switch (expr.e) {
                                case Expr.EIdent(name): name;
                                default: "";
                            }

                            if (methodName == target) {
                                // Check if this matches our ordinal requirement
                                if (ordinal == -1 || matchCount == ordinal) {
                                    trace("Target method matched at ordinal " + matchCount + "! Injecting " + shift + " call to: " + target);

                                    var insertIndex = (shift == Shift.BEFORE) ? i : i + 1;

                                    for (j in 0...sourceExprs.length)
                                        targetExprs.insert(insertIndex + j, sourceExprs[j]);

                                    i += sourceExprs.length + 1;
                                    injectionPerformed = true;

                                    // If targeting specific ordinal, we're done after injection
                                    if (ordinal != -1) break;
                                } else {
                                    i++;
                                }

                                matchCount++;
                            } else {
                                i++;
                            }
                        default:
                            i++;
                    }
                }

                if (ordinal != -1 && !injectionPerformed) {
                    trace("Error: Requested ordinal " + ordinal + " but only found " + matchCount + " occurrences of '" + target + "'");
                }
            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }


    public static function extractSourceExpressions(sourceFunc:FunctionDecl):Null<Array<Expr>> {
        return switch (sourceFunc.expr.e) {
            case Expr.EBlock(exprs): exprs;
            default:
                trace("Source function is not an EBlock, please provide an actual function!");
                null;
        }
    }

    public function shiftFromStr(str:String):Shift {
        return switch (str) {
            case "BEFORE": Shift.BEFORE;
            case "AFTER": Shift.AFTER;
            default: Shift.BEFORE;
        };
    }

    public function atFromStr(str:String):At {
        return switch (str) {
            case "HEAD": At.HEAD;
            case "TAIL": At.TAIL;
            case "INVOKE": At.INVOKE;
            case "RETURN": At.RETURN;
            default: At.HEAD;
        };
    }

    public static function validateInstances(targetInstance:Dynamic, sourceInstance:Dynamic, targetFuncName:String, sourceFuncName:String):Null<ValidationDef> {
        var targetFuncs = ASTUtil.getFuncCache(targetInstance);
        var sourceFuncs = ASTUtil.getFuncCache(sourceInstance);

        if (targetFuncs == null) trace("Failed to get function from target");
        if (targetFuncs == null || sourceFuncs == null) {
            trace("Failed to get function caches");
            return null;
        }

        var targetFunc = targetFuncs.get(targetFuncName);
        var sourceFunc = sourceFuncs.get(sourceFuncName);

        if (targetFunc == null) {
            trace("Target function " + targetFuncName + " not found");
            return null;
        }

        if (sourceFunc == null) {
            trace("Source function " + sourceFuncName + " not found");
            return null;
        }

        return {targetFuncs: targetFuncs, sourceFuncs: sourceFuncs, targetFunc: targetFunc, sourceFunc: sourceFunc};
    }
}

enum At {
    HEAD; // Inject at beginning
    TAIL; // Inject at end
    INVOKE; // At a target
    RETURN; // Before every return statement
}

enum Shift {
    BEFORE;
    AFTER;
}

typedef ValidationDef = {targetFuncs:Map<String, FunctionDecl>, sourceFuncs:Map<String, FunctionDecl>, targetFunc:FunctionDecl, sourceFunc:FunctionDecl}