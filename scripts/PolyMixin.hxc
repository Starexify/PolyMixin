import funkin.modding.module.ScriptedModule;
import funkin.util.ReflectUtil;
import hscript.Expr;
import Lambda;
import Std;

/**
 * Utility module providing methods and functions for injection, overwriting or modifying
 * `PolymodScriptedClass` instances dynamically by manipulating their AST.
 */
class PolyMixin extends ScriptedModule {
    static var _instance:PolyMixin;
    public static var instance(get, set):PolyMixin;

    static function set_instance(value:PolyMixin):PolyMixin { return _instance = value; }

    static function get_instance():PolyMixin { return _instance; }

    function new() {
        super("PolyMixin");
        PolyMixin.instance = this;
    }

    // MARK: - Public API Methods
    public static function modifyRecByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, callFuncName:String, ?at:At, ?target:String, ?ordinal:Int):Bool {
        at = at ?? At.INVOKE;
        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        var callFunc = validation.sourceFuncs.get(callFuncName);
        if (callFunc == null) {
            trace("Call function " + callFuncName + " not found");
            return false;
        }

        var newFunc = switch (at) {
            case At.INVOKE:
                injectFunction(targetInstance, sourceInstance, sourceFuncName);
                modifyRec(validation.targetFunc, callFunc, sourceFuncName, target, ordinal);
            default:
                trace("Only At.INVOKE is supported for this function!");
                return false;
        }

        validation.targetFuncs.set(targetFuncName, newFunc);
        return true;
    }

    public static function modifyByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, callFuncName:String, at:At, ?target:String, ?ordinal:Int):Bool {
        at = at ?? At.RETURN;
        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        var callFunc = validation.sourceFuncs.get(callFuncName);
        if (callFunc == null) {
            trace("Call function " + callFuncName + " not found");
            return false;
        }

        var newFunc = switch (at) {
            case At.RETURN:
                injectFunction(targetInstance, sourceInstance, sourceFuncName);
                modifyReturnValue(validation.targetFunc, callFunc, sourceFuncName);
            case At.INVOKE:
                injectFunction(targetInstance, sourceInstance, sourceFuncName);
                modifyExprValue(validation.targetFunc, callFunc, sourceFuncName, target, ordinal);
            default:
                trace("Only At.RETURN/At.INVOKE are supported for this function !");
                return false;
        }

        validation.targetFuncs.set(targetFuncName, newFunc);
        return true;
    }

    public static function injectByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, at:At, ?target:String, ?ordinal:Int, ?shift:Shift):Bool {
        at = at ?? At.HEAD;

        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        var newFunc = switch (at) {
            case At.INVOKE: injectAtTarget(validation.targetFunc, validation.sourceFunc, target, ordinal, shift);
            default: inject(validation.targetFunc, validation.sourceFunc, at, ordinal);
        }

        validation.targetFuncs.set(targetFuncName, newFunc);
        return true;
    }

    public static function injectByNameStr(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, at:String, ?target:String, ?ordinal:Int, ?shift:String):Bool {
        return injectByName(targetInstance, targetFuncName, sourceInstance, sourceFuncName, instance.atFromStr(at), target, ordinal, instance.shiftFromStr(shift));
    }

    public static function overwrite(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String):Bool {
        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        validation.targetFuncs.set(targetFuncName, validation.sourceFunc);
        return true;
    }

    public static function injectFunction(targetInstance:Dynamic, sourceInstance:Dynamic, sourceFuncName:String):Bool {
        var targetFuncs = ASTUtil.getFuncCache(targetInstance);
        var targetFields = ASTUtil.getFields(targetInstance);
        var sourceFuncs:Map<String, FunctionDecl> = ASTUtil.getFuncCache(sourceInstance);

        if (targetFuncs == null || sourceFuncs == null || targetFields == null) {
            trace("Failed to get required caches/fields");
            return false;
        }

        var sourceFunc = sourceFuncs.get(sourceFuncName);
        if (sourceFunc == null) {
            trace("Source function " + sourceFuncName + " not found");
            return false;
        }

        var sourceFields:Array<FieldDecl> = ReflectUtil.getField(sourceInstance, "_c").fields;
        var sourceField:FieldDecl = Lambda.find(sourceFields, (f) -> f.name == sourceFuncName);

        if (sourceField == null) {
            trace("Source field " + sourceFuncName + " not found");
            return false;
        }

        targetFields.fields.push(sourceField);
        targetFields.cached.set(sourceFuncName, sourceField);
        targetFuncs.set(sourceFuncName, sourceFunc);

        return true;
    }

    // MARK: - Core Injection Logic
    public static function modifyRec(targetFunc:FunctionDecl, callFunc:FunctionDecl, sourceFuncName:String, ?target:String, ?ordinal:Int):FunctionDecl {
        if (target == null || target == "") {
            trace("No mixins applied to this function. `target` injection param is null or empty, give an actual target!");
            return targetFunc;
        }
        if (ordinal == null) ordinal = 0;
        var targets = target.split(".");

        var newCall = switch (callFunc.expr.e) {
            case Expr.EBlock(expr): expr[0].e;
            default:
                trace("The source function " + sourceFuncName + " must provide an empty function recall for mixins to be able to modify the return value!");
                return targetFunc;
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(exprs):
                var count = 0;
                for (i in 0...exprs.length) {
                    switch (exprs[i].e) {
                        case Expr.ECall(callExpr, params):
                            var newExpr = PolyMixin.instance.recursiveSearch(exprs[i].e, newCall, targets, ordinal, count);
                            if (newExpr.modified) {
                                trace("Receiver found, replacing '" + targets[0] + "' with '" + sourceFuncName + "()'");
                                exprs[i].e = newExpr.expr;
                                return targetFunc;
                            }
                            count = newExpr.curCount;
                    }
                }
            default: trace("No EBlock found in the function, no mixins were applied!");
        }

        return targetFunc;
    }

    public function recursiveSearch(tgCall:Expr, newCall:Expr, targets:Array<String>, ordinal:Int, curCount:Int):Recursive {
        var targetExpr = targets[0];
        var targetCall = targets[1];
        switch (tgCall) {
            case Expr.ECall(tgExpr, params):
                switch (tgExpr.e) {
                    case Expr.EField(expr, f):
                        switch (expr.e) {
                            case Expr.EIdent(v):
                                if (v == targetExpr && f == targetCall) {
                                    //trace("Call found: " + v + "." + f + " (occurrence " + curCount + ")");

                                    if (curCount == ordinal) {
                                        switch (newCall) {
                                            case Expr.ECall(callE, args):
                                                args[0].e = expr.e;
                                                for (i in 0...params.length) {
                                                    args[i + 1].e = params[i].e;
                                                }
                                                expr.e = newCall;
                                        }
                                        return { expr: tgCall, modified: true, curCount: curCount + 1 };
                                    } else {
                                        return { expr: tgCall, modified: false, curCount: curCount + 1 };
                                    }
                                }
                                return { expr: tgExpr, modified: false, curCount: curCount };
                            case Expr.EField(fExpr): {
                                //trace(fExpr);
/*                        trace(fExpr);
                        trace(expr.e);
                        var result = recursiveSearch(fExpr, newCall, targets, ordinal, curCount);
                        return { expr: expr.e, modified: result.modified, curCount: result.curCount };*/
                            }
                            default: trace("No Expr.EField found for Reciever, please provide an actual receiver !");
                        }
                }
            default: trace("No Expr.ECall, please provide an actual receiver !");
        }

        return { expr: tgCall, modified: false, curCount: curCount };
    }

    public static function modifyExprValue(targetFunc:FunctionDecl, callFunc:FunctionDecl, sourceFuncName:String, ?target:String, ?ordinal:Int):FunctionDecl {
        /*      if (target == "" || target == null) {
            trace("No mixins applied to this function. `target` injection param is null or empty, give an actual target!");
            return targetFunc;
        }*/
        if (ordinal == null) ordinal = 0;

        var newCall = switch (callFunc.expr.e) {
            case Expr.EBlock(expr): expr[0].e;
            default:
                trace("The source function " + sourceFuncName + " must provide an empty function recall for mixins to be able to modify the return value!");
                return targetFunc;
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var exprFound = false;
                var totalIfCount = 0;
                var matchingIfCount = 0;

                for (i in 0...targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.EIf(c, e1, e2):
                            var matchesTarget = true;
                            if (target != null)
                                matchesTarget = switch (c.e) {
                                    case Expr.EIdent(name):
                                        name == target;
                                    default: false;
                                }

                            if (matchesTarget) {
                                var shouldModify = true;
                                if (ordinal != null) shouldModify = (matchingIfCount == ordinal);

                                if (shouldModify) {
                                    var oldExpr = targetExprs[i].e;
                                    var wrappedCondE = wrapExpr(oldExpr, newCall, sourceFuncName, target, ordinal);
                                    targetExprs[i].e = wrappedCondE;
                                    exprFound = true;

                                    //trace("Modified matching if statement #" + matchingIfCount + " (total if #" + totalIfCount + ")");
                                }

                                matchingIfCount++;
                            }

                            totalIfCount++;
                        default: trace("No if statement found in the function, no mixins were applied!");
                    }
                }

            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function wrapExpr(oldExpr:Expr, newCall:Expr, sourceFuncName:String, target:String, ordinal:Int):Expr {
        switch (oldExpr) {
            case Expr.EIf(expr, e1, e2):
                switch (newCall) {
                    case Expr.ECall(callExpr, params): params[0].e = expr.e;
                }
                expr.e = newCall;
        }

        return oldExpr;
    }

    public static function modifyReturnValue(targetFunc:FunctionDecl, callFunc:FunctionDecl, sourceFuncName:String):FunctionDecl {
        var newCall = switch (callFunc.expr.e) {
            case Expr.EBlock(expr): expr[0].e;
            default:
                trace("The source function " + sourceFuncName + " must provide an empty function recall for mixins to be able to modify the return value!");
                return targetFunc;
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var returnFound = false;
                for (i in 0...targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.EReturn(e):
                            var oldReturn = targetExprs[i];
                            var wrappedReturn = wrapReturn(oldReturn, newCall, sourceFuncName);
                            targetExprs[i] = wrappedReturn;
                            returnFound = true;
                        default: trace("No return statement found in the function, no mixins were applied!");
                    }
                }
                if (!returnFound) trace("No return statement found in the function, no mixins were applied!");
            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function wrapReturn(oldReturn:Expr, newCall:Expr, sourceFuncName:String):Expr {
        switch (oldReturn.e) {
            case Expr.EReturn(expr):
                var original:Expr = expr.e;
                switch (newCall) {
                    case Expr.ECall(callExpr, params): params[0].e = original;
                    default:
                        trace("Invalid call expression in source function " + sourceFuncName);
                        return oldReturn;
                }
                expr.e = newCall;
        }
        return oldReturn;
    }

    public static function inject(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, at:At, ?ordinal:Int):FunctionDecl {
        var sourceExprs = extractSourceExpressions(sourceFunc);
        if (sourceExprs == null) return targetFunc;

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                switch (at) {
                    case At.HEAD: for (i in 0...sourceExprs.length) targetExprs.insert(i, sourceExprs[i]);
                    case At.RETURN: injectAtReturn(targetExprs, sourceExprs, ordinal);
                    case At.TAIL: for (expr in sourceExprs) targetExprs.push(expr);
                }
            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function injectAtReturn(targetExprs:Array<Expr>, sourceExprs:Array<Expr>, ordinal:Int) {
        if (ordinal == null) ordinal = -1;

        var i = 0;
        var returnCount = 0;
        while (i < targetExprs.length) {
            switch (targetExprs[i].e) {
                case Expr.EReturn(_):
                    if (ordinal == -1 || ordinal == returnCount) {
                        //trace("Found return #" + returnCount + " at index " + i + ", injecting code before it");
                        for (j in 0...sourceExprs.length) targetExprs.insert(i + j, sourceExprs[j]);
                        i += sourceExprs.length;
                    }
                    returnCount++;
                    i++;

                case Expr.EIf(condition, thenExpr, elseExpr):
                    //trace("Found if at index " + i + ", trying to inject code inside it");

                    switch (thenExpr.e) {
                        case Expr.EBlock(thenExprs):
                            returnCount = processReturns(thenExprs, sourceExprs, ordinal, returnCount);
                        default:
                    }

                    if (elseExpr != null) {
                        switch (elseExpr.e) {
                            case Expr.EBlock(elseExprs):
                                returnCount = processReturns(elseExprs, sourceExprs, ordinal, returnCount);
                            default:
                        }
                    }

                    i++;
                default: i++;
            }
        }
    }

    public static function processReturns(blockExprs:Array<Expr>, sourceExprs:Array<Expr>, ordinal:Int, returnCountRef:Int) {
        var i = 0;
        var currentReturnCount = returnCountRef;

        while (i < blockExprs.length) {
            switch (blockExprs[i].e) {
                case Expr.EReturn(_):
                    if (ordinal == -1 || ordinal == currentReturnCount) {
                        //trace("Found return #" + currentReturnCount + " in block at index " + i);
                        for (j in 0...sourceExprs.length) blockExprs.insert(i + j, sourceExprs[j]);
                        i += sourceExprs.length;
                    }
                    currentReturnCount++;
                    i++;

                case Expr.EIf(_, thenExpr, elseExpr):
                    switch (thenExpr.e) {
                        case Expr.EBlock(thenExprs):
                            currentReturnCount = processReturns(thenExprs, sourceExprs, ordinal, currentReturnCount);
                        default:
                    }
                    if (elseExpr != null) {
                        switch (elseExpr.e) {
                            case Expr.EBlock(elseExprs):
                                currentReturnCount = processReturns(elseExprs, sourceExprs, ordinal, currentReturnCount);
                            default:
                        }
                    }
                    i++;

                default: i++;
            }
        }

        return currentReturnCount;
    }

    public static function injectAtTarget(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, target:String, ordinal:Int, shift:Shift):FunctionDecl {
        if (target == "" || target == null) {
            trace("No mixins applied to this function. `target` injection param is null or empty, give an actual target!");
            return targetFunc;
        }
        shift = shift ?? Shift.BEFORE;
        ordinal = ordinal ?? 0;

        var sourceExprs = extractSourceExpressions(sourceFunc);
        if (sourceExprs == null) return targetFunc;

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var matchCount = 0;
                var targetIndex = -1;

                for (i in 0...targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.ECall(expr, params):
                            var methodName = switch (expr.e) {
                                case Expr.EIdent(name): name;
                                default: "";
                            }

                            if (methodName == target) {
                                //trace("Found target '" + target + "' at index " + i + " (match #" + matchCount + ")");

                                if (ordinal == -1 || matchCount == ordinal) targetIndex = i;
                                matchCount++;
                            }
                        default:
                    }
                }

                if (targetIndex == -1) {
                    trace("Error: Could not find target '" + target + "' at ordinal " + ordinal);
                    return targetFunc;
                }

                // Perform the injection
                var insertIndex = (Std.string(shift) == "Shift.BEFORE") ? targetIndex : targetIndex + 1;

                for (j in 0...sourceExprs.length) targetExprs.insert(insertIndex + j, sourceExprs[j]);

            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    // MARK: - Utility Methods
    public static function extractSourceExpressions(sourceFunc:FunctionDecl):Null<Array<Expr>> {
        return switch (sourceFunc.expr.e) {
            case Expr.EBlock(exprs): exprs;
            default:
                trace("Source function is not an EBlock, please provide an actual function!");
                null;
        }
    }

    public function shiftFromStr(str:String):Shift {
        return switch (str) {
            case "BEFORE": Shift.BEFORE;
            case "AFTER": Shift.AFTER;
            default: Shift.BEFORE;
        };
    }

    public function atFromStr(str:String):At {
        return switch (str) {
            case "HEAD": At.HEAD;
            case "TAIL": At.TAIL;
            case "INVOKE": At.INVOKE;
            case "RETURN": At.RETURN;
            default: At.HEAD;
        };
    }

    public static function validateInstances(targetInstance:Dynamic, sourceInstance:Dynamic, targetFuncName:String, sourceFuncName:String):Null<ValidationDef> {
        var targetFuncs = ASTUtil.getFuncCache(targetInstance);
        var sourceFuncs = ASTUtil.getFuncCache(sourceInstance);

        if (targetFuncs == null) trace("Failed to get function from target");
        if (targetFuncs == null || sourceFuncs == null) {
            trace("Failed to get function caches");
            return null;
        }

        var targetFunc = targetFuncs.get(targetFuncName);
        var sourceFunc = sourceFuncs.get(sourceFuncName);

        if (targetFunc == null) {
            trace("Target function " + targetFuncName + " not found");
            return null;
        }

        if (sourceFunc == null) {
            trace("Source function " + sourceFuncName + " not found");
            return null;
        }

        return {targetFuncs: targetFuncs, sourceFuncs: sourceFuncs, targetFunc: targetFunc, sourceFunc: sourceFunc};
    }
}

enum At {
    HEAD; // Inject at beginning
    TAIL; // Inject at end
    INVOKE; // At a target
    RETURN; // Before every return statement
}

enum Shift {
    BEFORE;
    AFTER;
}

typedef Recursive = {expr:Expr, modified:Bool, curCount:Int}

typedef ValidationDef = {targetFuncs:Map<String, FunctionDecl>, sourceFuncs:Map<String, FunctionDecl>, targetFunc:FunctionDecl, sourceFunc:FunctionDecl}