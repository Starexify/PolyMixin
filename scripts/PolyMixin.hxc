import funkin.modding.module.ScriptedModule;
import funkin.util.ReflectUtil;
import hscript.Expr;
import Lambda;

/**
 * Utility module providing static methods and functions for injection, overwriting or modifying
 * `PolymodScriptedClass` instances dynamically by manipulating their AST.
 */
class PolyMixin extends ScriptedModule {
    function new() {
        super("PolyMixin");
    }

    /**
     * Modifies a target function by wrapping its return values with a call to a mixin function.
     *
     * This method combines function injection and return-value modification to enable mixins
     * that alter or override the return value of an existing function. It works by copying
     * the mixin function into the target instance (via {@link injectFunction}) and then
     * replacing every `return` statement in the target function with a wrapped call.
     *
     * The mixin function must provide an "empty recall" â€” i.e., a function that calls the
     * designated `callFuncName` with a placeholder argument. This is necessary so the AST
     * can be manipulated to insert the original return value as the argument.
     *
     * Currently, only `At.RETURN` is supported as an injection point.
     *
     * @param targetInstance The instance containing the target function to modify.
     * @param targetFuncName The name of the function in the target instance to modify.
     * @param sourceInstance The instance containing the mixin functions.
     * @param sourceFuncName The name of the mixin function providing logic to inject.
     * @param callFuncName The helper/empty-call function used as a template for wrapping return values.
     * @param at Where to inject (currently only {@code At.RETURN} is supported).
     * @return True if the modification succeeded, false otherwise.
     *
     *
     * @example
     * // Original target function:
     *
     * function getValue() {
     *     return 5;
     * }
     *
     *
     * // Mixin function:
     *
     * function modifyValue(original:Int) {
     *     modifyValue(); // empty recall, used as AST template
     *     return original + 10;
     * }
     *
     *
     * // Apply mixin:
     *
     * PolyMixin.modifyByName(TargetClass.instance, "getValue", MixinClass.instance, "modifyValue", "modifyValue", At.RETURN);
     *
     * // Resulting behavior: getValue() now returns 15 instead of 5.
     */
    public static function modifyByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, callFuncName:String, ?at:At):Bool {
        if (at == null) at = At.RETURN;

        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        var callFunc = validation.sourceFuncs.get(callFuncName);
        if (callFunc == null) {
            trace("Call function " + callFuncName + " not found");
            return false;
        }

        var newFunc = switch (at) {
            case At.RETURN:
                injectFunction(targetInstance, sourceInstance, sourceFuncName);
                modifyReturnValue(validation.targetFunc, callFunc, sourceFuncName);
            default:
                trace("Only At.Return works at the moment");
                return false;
        }

        validation.targetFuncs.set(targetFuncName, newFunc);
        return true;
    }

    public static function modifyReturnValue(targetFunc:FunctionDecl, callFunc:FunctionDecl, sourceFuncName:String) {
        var newCall = switch (callFunc.expr.e) {
            case Expr.EBlock(expr): expr[0].e;
            default:
                trace("The source function " + sourceFuncName + " must provide an empty function recall for mixins to be able to modify the return value!");
                return targetFunc;
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var returnFound = false;
                for (i in 0...targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.EReturn(e):
                            var oldReturn = targetExprs[i];
                            var wrappedReturn = wrapReturn(oldReturn, newCall, sourceFuncName);
                            targetExprs[i] = wrappedReturn;
                            returnFound = true;
                        default: trace("No return statement found in the function, no mixins were applied!");
                    }
                }
                if (!returnFound) trace("No return statement found in the function, no mixins were applied!");
            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function wrapReturn(oldReturn:Expr, newCall:Expr, sourceFuncName:String):Expr {
        switch (oldReturn.e) {
            case Expr.EReturn(expr):
                var original:Expr = expr.e;
                switch (newCall) {
                    case Expr.ECall(callExpr, params): params[0].e = original;
                    default:
                        trace("Invalid call expression in source function " + sourceFuncName);
                        return oldReturn;
                }
                expr.e = newCall;
        }
        return oldReturn;
    }

    /**
     * Copies a function from one instance to another, effectively adding
     * the source function to the target instance.
     *
     * This modifies both the function cache and the AST field list of the target,
     * making the function behave as if it were originally declared there.
     *
     * @param targetInstance The instance that will receive the new function.
     * @param sourceInstance The instance containing the function to copy.
     * @param sourceFuncName The name of the function to copy from the source instance.
     * @return True if the function was successfully copied, false otherwise.
     *
     *
     * @example
     * // Copy `helper` function from `MixinClass` into `TargetClass`
     *
     * PolyMixin.injectFunction(TargetClass.instance, MixinClass.instance, "helper");
     */
    public static function injectFunction(targetInstance:Dynamic, sourceInstance:Dynamic, sourceFuncName:String):Bool {
        var targetFuncs = ASTUtil.getFuncCache(targetInstance);
        var targetFields = ASTUtil.getFields(targetInstance);
        var sourceFuncs:Map<String, FunctionDecl> = ASTUtil.getFuncCache(sourceInstance);

        if (targetFuncs == null || sourceFuncs == null || targetFields == null) {
            trace("Failed to get required caches/fields");
            return false;
        }

        var sourceFunc = sourceFuncs.get(sourceFuncName);
        if (sourceFunc == null) {
            trace('Source function "$sourceFuncName" not found');
            return false;
        }

        var sourceFields:Array<FieldDecl> = ReflectUtil.getField(sourceInstance, "_c").fields;
        var sourceField:FieldDecl = Lambda.find(sourceFields, (f) -> f.name == sourceFuncName);

        if (sourceField == null) {
            trace("Source field " + sourceFuncName + " not found");
            return false;
        }

        targetFields.fields.push(sourceField);
        targetFields.cached.set(sourceFuncName, sourceField);
        targetFuncs.set(sourceFuncName, sourceFunc);

        return true;
    }

    /**
     * Injects the contents of a source function into a target function by name.
     *
     * This is the main entry point for performing mixin-style injections. Depending on `at`,
     * the injection may occur at the start of the target function, before returns, at the end,
     * or around a specific method call inside the function body.
     *
     * @param targetInstance The instance containing the target function.
     * @param targetFuncName The name of the target function to modify.
     * @param sourceInstance The instance containing the source function.
     * @param sourceFuncName The name of the source function to inject.
     * @param at Where to inject (`At.HEAD`, `At.RETURN`, `At.TAIL`, or `At.INVOKE`).
     * @param target (Optional) The name of the method call to inject around (only used with `At.INVOKE`).
     * @param ordinal (Optional) The occurrence index of the target method call (-1 for all occurrences).
     * @param shift (Optional) Whether to inject before or after the target call (`Shift.BEFORE` or `Shift.AFTER`).
     * @return True if the injection succeeded, false otherwise.
     *
     *
     * @example
     * // Inject `onUpdateMixin` at the head of `onUpdate`
     *
     * PolyMixin.injectByName(TargetClass.instance, "onUpdate", MixinClass.instance, "onUpdateMixin", At.HEAD);
     *
     * @example
     * // Inject before the first `doSmth` call inside the `onUpdate` function
     *
     * PolyMixin.injectByName(TargetClass.instance, "onUpdate", MixinClass.instance, "onUpdateMixin", At.INVOKE, "doSmth", 0, Shift.BEFORE);
     */
    public static function injectByName(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String, at:At, ?target:String, ?ordinal:Int, ?shift:Shift):Bool {
        if (at == null) at = At.HEAD;
        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        var newFunc = switch (at) {
            case At.INVOKE: injectAtTarget(validation.targetFunc, validation.sourceFunc, target, ordinal, shift);
            default: inject(validation.targetFunc, validation.sourceFunc, at);
        }

        validation.targetFuncs.set(targetFuncName, newFunc);
        return true;
    }

    public static function inject(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, at:At):FunctionDecl {
        var sourceExpr:Expr.EBlock = sourceFunc.expr.e;
        var sourceExprs:Array<Expr> = [];

        switch (sourceExpr) {
            case Expr.EBlock(exprs):
                sourceExprs = exprs;
            default: trace("Source function is not an EBlock, please provide an actual function!");
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                switch (at) {
                    case At.HEAD:
                        for (i in 0...sourceExprs.length) targetExprs.insert(i, sourceExprs[i]);
                    case At.RETURN:
                        for (i in 0...targetExprs.length) {
                            switch (targetExprs[i].e) {
                                case Expr.EReturn(returnExpr):
                                    trace("Found return at index " + i + ", injecting code before it");
                                    for (j in 0...sourceExprs.length) targetExprs.insert(i + j, sourceExprs[j]);
                            }
                        }
                    case At.TAIL:
                        for (expr in sourceExprs) targetExprs.push(expr);
                }
            default:
                trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    public static function injectAtTarget(targetFunc:FunctionDecl, sourceFunc:FunctionDecl, target:String, ordinal:Int, shift:Shift):FunctionDecl {
        if (target == "" || target == null) {
            trace("No mixins applied to this function. `target` injection param is null or empty, give an actual target!");
            return targetFunc;
        }
        if (shift == null) shift = Shift.BEFORE;
        if (ordinal == null) ordinal = 0;

        var sourceExpr:Expr.EBlock = sourceFunc.expr.e;
        var sourceExprs:Array<Expr> = [];

        switch (sourceExpr) {
            case Expr.EBlock(exprs):
                sourceExprs = exprs;
            default: trace("Source function is an EBlock, please provide an actual function!");
        }

        switch (targetFunc.expr.e) {
            case Expr.EBlock(targetExprs):
                var matchCount = 0;
                var i = 0;
                var injectionPerformed = false;

                while (i < targetExprs.length) {
                    switch (targetExprs[i].e) {
                        case Expr.ECall(expr, params):
                            var methodName = switch (expr.e) {
                                case Expr.EIdent(name): name;
                                default: "";
                            }

                            if (methodName == target) {
                                // Check if this matches our ordinal requirement
                                if (ordinal == -1 || matchCount == ordinal) {
                                    trace("Target method matched at ordinal " + matchCount + "! Injecting " + shift + " call to: " + target);

                                    var insertIndex = (shift == Shift.BEFORE) ? i : i + 1;

                                    for (j in 0...sourceExprs.length)
                                        targetExprs.insert(insertIndex + j, sourceExprs[j]);

                                    i += sourceExprs.length + 1;
                                    injectionPerformed = true;

                                    // If targeting specific ordinal, we're done after injection
                                    if (ordinal != -1) break;
                                } else {
                                    i++;
                                }

                                matchCount++;
                            } else {
                                i++;
                            }
                        default:
                            i++;
                    }
                }

                if (ordinal != -1 && !injectionPerformed) {
                    trace("Error: Requested ordinal " + ordinal + " but only found " + matchCount + " occurrences of '" + target + "'");
                }
            default: trace("Target function is NOT an EBlock!");
        }

        return targetFunc;
    }

    /**
     * Replaces a target function entirely with a source function.
     *
     * After this operation, the target function no longer contains its original body
     * and instead becomes identical to the source function.
     *
     * @param targetInstance The instance containing the target function.
     * @param targetFuncName The name of the target function to replace.
     * @param sourceInstance The instance containing the source function.
     * @param sourceFuncName The name of the source function to use as replacement.
     * @return True if the replacement was successful, false otherwise.
     *
     *
     * @example
     * // Replace onUpdate() entirely with onUpdateMixin()
     *
     * PolyMixin.overwrite(targetInstance, "onUpdate", sourceInstance, "onUpdateMixin");
     */
    public static function overwrite(targetInstance:Dynamic, targetFuncName:String, sourceInstance:Dynamic, sourceFuncName:String):Bool {
        var validation = validateInstances(targetInstance, sourceInstance, targetFuncName, sourceFuncName);
        if (validation == null) return false;

        validation.targetFuncs.set(targetFuncName, validation.sourceFunc);

        return true;
    }

    public static function atFromStr(str:String):At {
        switch (str) {
            case "HEAD": return At.HEAD;
            case "TAIL": return At.TAIL;
            case "INVOKE": return At.INVOKE;
            case "RETURN": return At.RETURN;
            default: return At.HEAD;
        }
    }

    public static function validateInstances(targetInstance:Dynamic, sourceInstance:Dynamic, targetFuncName:String, sourceFuncName:String):Null<ValidationDef> {
        var targetFuncs = ASTUtil.getFuncCache(targetInstance);
        var sourceFuncs = ASTUtil.getFuncCache(sourceInstance);

        if (targetFuncs == null || sourceFuncs == null) {
            trace("Failed to get function caches");
            return null;
        }

        var targetFunc = targetFuncs.get(targetFuncName);
        var sourceFunc = sourceFuncs.get(sourceFuncName);

        if (targetFunc == null) {
            trace('Target function "$targetFuncName" not found');
            return null;
        }

        if (sourceFunc == null) {
            trace('Source function "$sourceFuncName" not found');
            return null;
        }

        return {targetFuncs: targetFuncs, sourceFuncs: sourceFuncs, targetFunc: targetFunc, sourceFunc: sourceFunc};
    }
}

typedef ValidationDef = {targetFuncs:Map<String, FunctionDecl>, sourceFuncs:Map<String, FunctionDecl>, targetFunc:FunctionDecl, sourceFunc:FunctionDecl}

enum At {
    HEAD; // Inject at beginning
    TAIL; // Inject at end
    INVOKE; // At a target
    RETURN; // Before every return statement
}

enum Shift {
    BEFORE;
    AFTER;
}