import funkin.util.ReflectUtil;
import hscript.Expr;
import polymod.hscript._internal.PolymodClassDeclEx;

class MixinAnnotationProcessor {

    public static function applyMixins(source:Dynamic, targetInstance:Dynamic):Bool {
        var _c:PolymodClassDeclEx = ReflectUtil.getField(source, "_c");

        if (_c == null) {
            trace("No class definition found.");
            return false;
        }

        applyMixinField(_c.fields, targetInstance, source, _c.name);
        applyMixinField(_c.staticFields, targetInstance, source, _c.name);

        return true;
    }

    public static function applyMixinField(fields:Array<FieldDecl>, target:Dynamic, source:Dynamic, className:String):Void {
        if (fields == null) return;
        for (field in fields) {
            for (meta in field.meta) {
                var funcName = field.name;
                switch (meta.name) {
                    case ":Overwrite":
                        var methodName:String = retrieveParams(meta, ["method"]).method;
                        if (methodName != null) {
                            trace("Overwriting method: " + methodName + "() with " + funcName + "() from class " + className);
                            PolyMixin.overwrite(target, methodName, source, funcName);
                        } else trace("Warning: method name is null for " + funcName);
                    case ":Inject":
                        var params:InjectionParams = retrieveParams(meta, ["method", "at", "target", "ordinal", "shift"]);
                        if (params.method != null) {
                            trace("Injecting into method: " + params.method + "() with params: " + params + " and function: " + funcName + "() from class " + className);
                            switch (params.at) {
                                case "INVOKE":
                                    if (params.target != null) PolyMixin.injectByNameStr(target, params.method, source, funcName, params.at, params.target, params.ordinal, params.shift);
                                    else trace("Warning: target is null for " + funcName);
                                default:
                                    PolyMixin.injectByNameStr(target, params.method, source, funcName, params.at);
                            }
                        } else trace("Warning: method name is null for " + funcName);
                    case ":ModifyReturn":
                        var params:ModifyReturnParams = retrieveParams(meta, ["method", "at", "call"]);
                        if (params.method != null) {
                            trace("Modifying return from method: " + params.method + "() with params: " + params + " and function: " + funcName + "() from class " + className);
                            if (params.method != null) PolyMixin.modifyByName(target, params.method, source, funcName, params.call);
                        } else trace("Warning: method name is null for " + funcName);
                    case ":InjectFunction":
                        trace("Injecting function: " + funcName + "() from class " + className);
                        PolyMixin.injectFunction(target, source, funcName);

                    default:
                }
            }
        }
    }

    public static function retrieveParams(meta:Metadata, ?allowed:Array<String>):Dynamic {
        var result:Dynamic = {};
        for (param in meta.params) {
            switch (param.e) {
                case Expr.EBinop(_, e1, e2):
                    switch (e1.e) {
                        case Expr.EIdent(paramName):
                            if (allowed == null || allowed.indexOf(paramName) != -1) {
                                var value:Dynamic = null;

                                switch (e2.e) {
                                    case Expr.EConst(c):
                                        switch (c) {
                                            case Const.CString(str):
                                                value = str;
                                            case Const.CInt(i):
                                                value = i;
                                        }
                                    case Expr.EIdent(id):
                                        value = id;
                                    case _:
                                        trace("Unhandled RHS for " + paramName + ": " + e2.e);
                                }

                                ReflectUtil.setField(result, paramName, value);
                            }
                    }
            }
        }

        return result;
    }
}

typedef BasicParams = {method:String}
typedef InjectionParams = {method:String, at:String, target:String, ordinal:Int, shift:String}
typedef ModifyReturnParams = {method:String, at:String, call:String}
